package com.landoop.jdbc

import com.landoop.rest.domain.Credentials
import com.landoop.jdbc.domain.LsqlData
import com.landoop.jdbc.domain.LsqlJdbcData
import com.landoop.rest.RestClient
import java.sql.*

class LsqlJdbcStatement(private val client: RestClient,
                        private var token: String,
                        private val user: String,
                        private val password: String) : Statement, AutoCloseable {

  private var currentResultSet: LsqlJdbcResultSet? = null

  override fun close() {
    // statements have no resources associated with them
  }

  @Throws(SQLException::class)
  override fun executeQuery(lsql: String): ResultSet? {
    this.execute(lsql)
    return currentResultSet
  }

  @Throws(SQLException::class)
  override fun executeUpdate(lsql: String): Int = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun executeUpdate(sql: String, autoGeneratedKeys: Int): Int = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun executeUpdate(sql: String, columnIndexes: IntArray?): Int = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun executeUpdate(sql: String, columnNames: Array<String>?): Int = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun execute(lsql: String, autoGeneratedKeys: Int): Boolean = execute(lsql)

  @Throws(SQLException::class)
  override fun execute(lsql: String, columnIndexes: IntArray?): Boolean = execute(lsql)

  @Throws(SQLException::class)
  override fun execute(lsql: String, columnNames: Array<String>?): Boolean = execute(lsql)

  @Throws(SQLException::class)
  override fun execute(lsql: String): Boolean {
    val data: LsqlData = client.executeQuery(lsql, token, Credentials(user, password))

    // Parse response data
    val hasResultSets = data.data.isNotEmpty()

    this.currentResultSet = LsqlJdbcResultSet(this, LsqlJdbcData.from(data))

    return hasResultSets
  }

  @Throws(SQLException::class)
  override fun getResultSetConcurrency(): Int {
    return ResultSet.CONCUR_READ_ONLY
  }

  @Throws(SQLException::class)
  override fun getResultSetType(): Int {
    return ResultSet.TYPE_FORWARD_ONLY
  }

  @Throws(SQLException::class)
  override fun getGeneratedKeys(): ResultSet? = null

  @Throws(SQLException::class)
  override fun getResultSetHoldability(): Int = ResultSet.CLOSE_CURSORS_AT_COMMIT

  @Throws(SQLException::class)
  override fun addBatch(sql: String) = throw  SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun clearBatch() = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun executeBatch(): IntArray = throw SQLFeatureNotSupportedException()

  @Throws(SQLException::class)
  override fun isCloseOnCompletion(): Boolean = true

  @Throws(SQLException::class)
  override fun <T : Any?> unwrap(iface: Class<T>?): T {
    try {
      return iface!!.cast(this)
    } catch (e: ClassCastException) {
      throw SQLException(e)
    }
  }

  @Throws(SQLException::class)
  override fun getMaxRows(): Int = 0

  @Throws(SQLException::class)
  override fun getMaxFieldSize(): Int = 0

  override fun getResultSet(): ResultSet? = null

  @Throws(SQLException::class)
  override fun cancel() {
  }

  @Throws(SQLException::class)
  override fun getConnection(): Connection = connection

  override fun getFetchSize(): Int = 0

  @Throws(SQLException::class)
  override fun isPoolable(): Boolean = false

  @Throws(SQLException::class)
  override fun setMaxFieldSize(max: Int) {
  }

  @Throws(SQLException::class)
  override fun setMaxRows(max: Int) {
  }

  @Throws(SQLException::class)
  override fun setFetchDirection(direction: Int) {
  }

  @Throws(SQLException::class)
  override fun setFetchSize(rows: Int) {
  }

  override fun setQueryTimeout(seconds: Int) {
  }

  @Throws(SQLException::class)
  override fun setEscapeProcessing(enable: Boolean) {
  }

  @Throws(SQLException::class)
  override fun setCursorName(name: String?) {
  }

  @Throws(SQLException::class)
  override fun setPoolable(poolable: Boolean) {
  }

  override fun getQueryTimeout(): Int = 0

  @Throws(SQLException::class)
  override fun getWarnings(): SQLWarning? = null

  @Throws(SQLException::class)
  override fun isClosed(): Boolean = closed

  @Throws(SQLException::class)
  override fun isWrapperFor(iface: Class<*>?): Boolean = this.javaClass.isAssignableFrom(iface)

  @Throws(SQLException::class)
  override fun getUpdateCount(): Int {
    require(!isClosed, { throw SQLException("Statement already closed.") })
    return -1
  }

  override fun clearWarnings() {
  }

  override fun closeOnCompletion() {
  }

  override fun getFetchDirection(): Int = 0

  override fun getMoreResults(): Boolean = false

  override fun getMoreResults(current: Int): Boolean = false
}